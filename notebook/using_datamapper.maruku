Using DataMapper
================

Database Configuration
----------------------

Database connections in Merb+DataMapper stack is configured in
the **config/database.yml** YAML file:

<pre>
---
# This is a sample database file for the DataMapper ORM
development: &defaults
  # These are the settings for repository :default
  adapter:  sqlite3
  database: db/sample\_development.sqlite3
  # Add more repositories
  # repositories:
  #   repo1:
  #     adapter:  postgresql
  #     database: sample\_development
  #     username: the\_user
  #     password: secrets
  #     host:     localhost
  #   repo2:
  #     ...

test:
  <<:       *defaults
  database: sample\_test

  # repositories:
  #   repo1:
  #     database: sample\_development

production:
  <<:       *defaults
  database: sample\_production

  # repositories:
  #   repo1:
  #     database: sample\_development
</pre>

With Datamapper config file you can define more than one database connection,
named **repositories**, to access more than one database at once.

### Problem: Activate SQL query logging

References:
* http://google.com/search?q=cache:NWjeEn85zB8J:rails.aizatto.com/2008/01/17/logging-datamapper-sql-queries-in-merb/+debug+sql+datamapper&hl=en&strip=1 

Declare a Model
---------------

References:
* DataMapper Properties "Getting Started": http://datamapper.org/docs/properties.html

### include DataMapper::Resource

In DataMapper a model is a class with included DataMapper::Resource module.

<pre>
class MyModel
  include DataMapper::Resource
end
</pre>

### property declaration
Whereas ActiveRecord map model attribute to database column, instead DataMapper
map database column to model attribute and you declare properties in the model class
definition file.

<pre>
class MyModel
  include DataMapper::Resource

  property :name, String
end
</pre>

#### key columns
Key Column properties have to be declared explicitly, so if you want it's an auto-increment column:

<pre>
class MyModel
  include DataMapper::Resource

  property :id,         Integer, :serial => true, :key => true
  property :name, String
end
</pre>

#### lazy loading
When you load a lot of records for a client list view a lot of
useless data it's loaded from the database too.

Too alleviate this problem DataMapper use lazy loading:

* complex types (Text, Yaml etc.) are lazy by default
* developers can explicit declare a property lazy
* properties can be grouped in laziness contexts

<pre>
class MyModel
  include DataMapper::Resource

  property :id,         Integer, :serial => true, :key => true
  property :name, String
  property :description, Text ### Lazy by default
  property :customer, String, :lazy => true
  property :attr1, String, :lazy => [:detail]
  property :attr2, String, :lazy => [:detail]
  property :attr3, String, :lazy => [:detail]
end
</pre>

Serialize and Deserialize models in JSON or YAML
------------------------------------------------

### Problem: lazy loading + single table inheritance + serialize
Solution: lazy loading contexts

* http://www.datamapper.org/articles/spotlight\_on\_laziness.html
* http://www.guyvdb.info/ruby/lazy-loading-properties-in-datamapper/

Validations
-----------

Validations in DataMapper working in the Rails-way, with various
validation helpers, with optional customized messages.

But DataMapper extend the Rails mechanism in various way.

To use validation you must include the library:
<pre>
require 'dm-validations'
</pre>

References:
* DataMapper Validation "Getting Started": http://datamapper.org/docs/validations.html
* DataMapper Validation "API": http://datamapper.rubyforge.org/DataMapper/Validate/ClassMethods.html

### autovalidations and customized messages

In property declaration developers can specify some autovalidation options:

* :nullable
* :unique
* :size / :length
* :format
* :message

### validations

If you want or need a more explicit validations rules you can use validation helper in Rails style:

<pre>
validates_length :name, :in => (1..10)

validates\_with\_method :sha\_id, :method => check\_sha\_id

def check\_sha\_id
    return [false, "have to be SHA1"] unless sha\_id.length == 40 and sha\_id =~ /[a-b0-9]+/
    return true
end
</pre>

Refer to **DataMapper::Validate::*Validator** classes in the apidoc for reference:

* DataMapper Validation "API": http://datamapper.rubyforge.org/

### validation contexts

A powerful feature of the DataMapper validations module is the **Validation Contexts**.

One can group validation rules to specified context (display, save, automated\_import, manual\_entry)
and call them with autogenerated helpers:

<pre>
  validates\_with\_method :sha\_id, :method => :check\_sha\_id, :context => [:sha1]

  def check\_sha\_id
    return [false, "have to be SHA1"] unless sha\_id.length == 40 and sha\_id =~ /[a-b0-9]+/
    return true
  end

  before :save, :generate\_sha\_id

  def generate\_sha\_id
    self.sha\_id = SHA1::sha1(self.summary) if not self.valid\_for\_sha1?

    # NOTE: self.valid? and self.valid\_for\_default? evaluate default context validations
  end
</pre>

References:
* http://adam.speaksoutofturn.com/archives/contextual\_validations\_with\_datamapper.html

### Problem: interaction of validation and hooks

Validation and autovalidation are evaluated before hooks and prevent hooked callback
from being called.

To circumvent this problem one can group validation he want to react in the callback
and manually valid records with a valid\_for\_context helper.

Example: if a property is **:nullable => false** it can't be populated by a before_save hooked method.

Associations
------------

References:
* DataMapper Associations "Getting Started": http://datamapper.org/docs/associations.html

### declare relationships

### Problem: customized associations

* http://www.datamapper.org/articles/spotlight\_on\_cpk.html